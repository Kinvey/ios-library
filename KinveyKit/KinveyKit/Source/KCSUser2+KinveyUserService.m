//
//  KCSUser2+KinveyUserService.m
//  KinveyKit
//
//  Created by Michael Katz on 12/10/13.
//  Copyright (c) 2013 Kinvey. All rights reserved.
//
// This software is licensed to you under the Kinvey terms of service located at
// http://www.kinvey.com/terms-of-use. By downloading, accessing and/or using this
// software, you hereby accept such terms of service  (and any agreement referenced
// therein) and agree that you have read, understand and agree to be bound by such
// terms of service and are of legal age to agree to such terms with Kinvey.
//
// This software contains valuable confidential and proprietary information of
// KINVEY, INC and is subject to applicable licensing agreements.
// Unauthorized reproduction, transmission or distribution of this file and its
// contents is a violation of applicable laws.
//

#import "KCSUser2+KinveyUserService.h"

#import "KinveyCoreInternal.h"
#import "KinveyDataStoreInternal.h"

KK2(Cleanup!)
#import "KinveyUser.h"
#import "KCSHiddenMethods.h"
#import "KCSDataModel.h"

#define KCSEntityKeyKMD @"_kmd"
#define KCSEntityKeyAuthtoken @"authtoken"
#define KCSEntityKeyEmailVerification @"emailVerification"
#define KCSUserAttributePassword @"password"

@implementation KCSUser2 (KinveyUserService)

#pragma mark - Credential Management

+ (BOOL) hasSavedCredentials
{
    return [KCSKeychain2 hasTokens];
}

+ (BOOL) clearSavedCredentials
{
    return [KCSKeychain2 deleteTokens];
}

+ (void) setActive:(id<KCSUser2>)user
{
    KK2(manage active user here)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated"
        [KCSClient sharedClient].currentUser = (id)user;
#pragma clang diagnostic pop
}

+ (id<KCSUser2>)activeUser
{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated"
    return (id)[KCSClient sharedClient].currentUser;
#pragma clang diagnostic pop
}

#pragma mark - User Creation
#warning logout current user

+ (void) createAutogeneratedUser:(NSDictionary *)fieldsAndValues completion:(KCSUser2CompletionBlock)completionBlock
{
    [self createUserWithUsername:nil password:nil fieldsAndValues:fieldsAndValues completion:completionBlock];
}

+ (void) createUserWithUsername:(NSString *)username password:(NSString *)password fieldsAndValues:(NSDictionary *)fieldsAndValues completion:(KCSUser2CompletionBlock)completionBlock
{
    if (!completionBlock) [[NSException exceptionWithName:NSInvalidArgumentException reason:@"Completion Block is nil" userInfo:nil] raise];
    if ((password == nil && username != nil) || (username == nil && password != nil)) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"Both username and password need to be set or both nil" userInfo:nil] raise];
    }
    
    NSMutableDictionary* createUserBody = [NSMutableDictionary dictionaryWithDictionary:fieldsAndValues];
    if (username && password) {
        createUserBody[KCSUserAttributeUsername] = username;
        createUserBody[KCSUserAttributePassword] = password;
    }
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
            [self setActive:nil];
            completionBlock(nil, error);
        } else {
            // Ok, we're really auth'd
            NSDictionary* userBody = [response jsonObject];
            [self setupActiveUser:userBody completion:completionBlock];
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.body = createUserBody;
    request.method = KCSRESTMethodPOST;
    [request start];
}

#pragma mark - Login 
+ (void)loginWithUsername:(NSString *)username password:(NSString *)password completion:(KCSUser2CompletionBlock)completionBlock
{
    if (!username) [[NSException exceptionWithName:NSInvalidArgumentException reason:@"username should not be nil." userInfo:nil] raise];
    if (!password) [[NSException exceptionWithName:NSInvalidArgumentException reason:@"password should not be nil." userInfo:nil] raise];
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
            [self setActive:nil];
            completionBlock(nil, error);
        } else {
            // Ok, we're really auth'd
            NSDictionary* userBody = [response jsonObject];
            [self setupActiveUser:userBody completion:completionBlock];
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.path = @[@"login"];
    request.method = KCSRESTMethodPOST;
    request.body = @{@"username":username, @"password":password};
    [request start];
}

#pragma mark - Logout


#pragma mark - User Object Management
+ (void) setupActiveUser:(NSDictionary*)body completion:(KCSUser2CompletionBlock)completionBlock
{
    //TODO: post user updated
    //TODO: user changed
#warning return error exceptions?
    
    if ([body isKindOfClass:[NSDictionary class]] == NO) {
        //check data type in case server is corrupted, yes this has happened
        [[NSException exceptionWithName:NSInternalInconsistencyException reason:@"Entity dictionary not returned for user" userInfo:nil] raise];
    }
    
    NSString* userId = body[KCSEntityKeyId];
    NSString* username = body [KCSUserAttributeUsername];
    if (userId == nil || username == nil) {
        //prevent that weird assertion that Colden was seeing
        [[NSException exceptionWithName:NSInternalInconsistencyException reason:@"Entity dictionary does not have username or user id" userInfo:nil] raise];
    }

    //Strip token
    NSMutableDictionary* modifiedProperties = [body mutableCopy];
    [modifiedProperties removeObjectForKey:KCSUserAttributePassword]; //discard the password in all cases

    NSMutableDictionary* metadata = [NSMutableDictionary dictionaryWithDictionary:modifiedProperties[KCSEntityKeyKMD]];
    NSString* authToken = [metadata popObjectForKey:KCSEntityKeyAuthtoken];
    
    if (authToken == nil) {
        [[NSException exceptionWithName:NSInternalInconsistencyException reason:@"Entity dictionary does not contain an auth token" userInfo:nil] raise];
    }
    
    //Handle Email Verification
    NSDictionary* emailVerification = [metadata popObjectForKey:KCSEntityKeyEmailVerification];
    NSString* verificationStatus = [emailVerification objectForKey:@"status"];

    //Put the updated properties back
    modifiedProperties[KCSEntityKeyMetadata] = metadata;
    
    //Make the user object
    KCSCollection* userCollection = [KCSCollection userCollection];
    id<KCSUser2> user = (id<KCSUser2>) [[KCSAppdataStore caches].dataModel objectFromCollection:userCollection.collectionName data:modifiedProperties];
    user.emailVerified = [verificationStatus isEqualToString:@"confirmed"];
    
    if (user.userId == nil || user.username == nil) {
        //prevent that weird assertion that Colden was seeing
        [[NSException exceptionWithName:NSInternalInconsistencyException reason:@"User object not properly configured with _id and username" userInfo:nil] raise];
    }
    
    [KCSKeychain2 setKinveyToken:authToken user:userId];
    [self setActive:user];
    
    [[KCSPush sharedPush] registerDeviceToken:^(BOOL success, NSError *error) {
        completionBlock(user, error);
    }];
}

+ (void)changePasswordForUser:(id<KCSUser2>)user password:(NSString*)newPassword completionBlock:(KCSUser2CompletionBlock)completionBlock
{
    if (newPassword == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"newPassword is nil" userInfo:nil] raise];
    }
    if (![user isEqual:[KCSUser activeUser]]){
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"Receiver is not current user.",
                                   NSLocalizedFailureReasonErrorKey: @"An operation only applicable to the current user was tried on a different user.",
                                   NSLocalizedRecoverySuggestionErrorKey:@"Only perform this action on the active user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        completionBlock(nil, userError);
    } else {
        KCSCollection* userCollection = [KCSCollection userCollection];
        NSDictionary* entity = [[KCSAppdataStore caches].dataModel jsonEntityForObject:user route:[userCollection route] collection:userCollection.collectionName];
        NSDictionary* body = [entity dictionaryByAddingDictionary:@{KCSUserAttributePassword : newPassword}];
        
        KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
            if (error) {
                KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
                completionBlock(nil, error);
            } else {
                // Ok, we're really auth'd
                NSDictionary* userBody = [response jsonObject];
                [self setupActiveUser:userBody completion:completionBlock];
            }

        }
                                                            route:KCSRESTRouteUser
                                                          options:@{KCSRequestLogMethod}
                                                      credentials:[KCSUser activeUser]];
        request.method = KCSRESTMethodPUT;
        request.path = @[user.userId];
        request.body = body;
        [request start];
    }
}
//TODO: test login
//TODO: test change password

//TODO: user object subclass and implementation
//TODO: clear TODOs
//TOOD: credentials for this and for v1 methods

@end
